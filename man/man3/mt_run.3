.TH "MT_RUN" "3" "17 January 2018 (v1.1.0)" "bofc.pl"

.SH NAME

mt_run - runs specific test

c/c++

.SH SYNOPSIS

.B #include <mtest.h>
.sp
.BI "void (*" function_name ")(void)
.br
.BI "mt_run(" function_name ")"
.br
.BI "mt_run_named(" function_name ", " test_name ")"
.br
.br
.BI "static void (*" mt_prepare_test ")(void)"
.br
.BI "static void (*" mt_cleanup_test ")(void)"
.sp

shell

.BI "mt_run <" function_name ">"

.SH DESCRIPTION

\fBmt_run\fR(#) runs a single test specified in \fIfunction_name\fR. Inside
function you can call \fBmt_assert\fR(3) and \fBmt_fail\fR(3). If none if these
functions is called inside test function, \fBmtest\fR will mark test as
successful. After function finishes its work, \fBmt_run\fR(3) will print test
status and a \fIfunction_name\fR to know which test passed or failed.

\fBmt_run_named\fR(3) works similar, but also takes \fItest_name\fR, that will
be printed instead of \fIfunction_name\fR when reporting test results.
\fItest_name\fR should be simple \fBconst char *\fR.

Optionally user can also set two function pointers \fImt_prepare_test\fR and
\fImt_cleanup_test\fR that take no argument and return nothing. These functions
will be called before and after calling test \fIfunction_name\fR.

When testing from shell, it is only neccessary to define functions
\fImt_prepare_test\fR and \fImt_cleanup_test\fR and \fBmtest\fR will use
then automatically

.SH EXAMPLE

c/c++

.nf
#include <mtest.h>
#include "foo.h"

mt_defs();

static void test(void)
{
    mt_assert(foo() == 0);
}

int main(void)
{
    mt_run(test);
    mt_run_named(test, "test param 1");
    mt_run_named(test, "test_param 2");

    mt_return();
}
.fi

shell

.nf
#!/bin/sh

. ./mtest.sh

test_one()
{
    a=1
    a=$((a + 1))
    mt_fail "[ $a -eq 2 ]"
}

mt_run test_one
mt_return
.fi

.SH "SEE ALSO"

.BR mt_defs (3),
.BR mt_defs_ext (3),
.BR mt_assert (3),
.BR mt_fail (3),
.BR mt_fok (3),
.BR mt_ferr (3),
.BR mt_return (3)
.BR mtest_overview (7),
