.TH "MTEST" "7" "15 January 2018 (v1.1.0)" "bofc.pl"

.SH "NAME"
\fBmtest_overview\fR - overview of \fBmtest\fR testing framework

.SH "DESCRIPTION"
\fBmtest\fR - very simple test framework for testing anything. mtest currently
supports following languages:

For c/c++

.sp
.BI "mt_defs()"
.br
.BI "mt_defs_ext()"
.br
.BI "mt_run(" function_name ")"
.br
.BI "mt_run_named(" function_name ", " test_name ")"
.br
.BI "mt_assert(" expression ")"
.br
.BI "mt_fail(" expression ")"
.br
.BI "mt_fok(" function_call ")"
.br
.BI "mt_ferr(" function_call ", " errno_value ")"
.br
.BI "mt_return()"
.sp

For shell

.sp
.BI "mt_run <" function_name ">"
.br
.BI "mt_fail <" expression ">"
.br
.BR "mt_return"
.sp

Test output is compatible with \fBTAP\fR (which stands for Test Anything
Protocol), so its output can be piped to another tool (like Jenkins or
automake tests) for nice output.

Each test binary (written in c/c++) should contain call to \fBmt_defs()\fR
anywhere in a global scope and \fBmt_return()\fR at the end of tests.

Tests in shell only requires \fBmt_return\fR at the end of tests

.SH "EXAMPLE"

.nf
#include <mtest.h>
#include <stdlib.h>
#include "file_to_test.h"

mt_defs(); /* defines necessary variables for mtest */

static void test_one(void)
{
    mt_assert(foo() == 0);
    mt_assert(bar() == 0);
}

static void test_two(void)
{
    unsigned char *mem;

    mt_assert((mem = malloc(100)) != NULL);
    mt_fok(baz(mem));
    mt_ferr(qux(mem), ENOSYS);

    free(mem);
}

int main(void)
{
    mt_run(test_one);
    mt_run(test_two);

    mt_return();
}
.fi

Example of using mt in posix shell

.nf
#!/bin/sh

. ./mtest.sh

test_one()
{
    a=1
    a=$((a + 1))
    mt_fail "[ $a -eq 2 ]"
}

mt_run test_one
mt_return
.fi

.SH "SEE ALSO"
.BR mt_defs (3),
.BR mt_defs_ext (3),
.BR mt_run (3),
.BR mt_assert (3),
.BR mt_fail (3),
.BR mt_fok (3),
.BR mt_ferr (3),
.BR mt_return (3)
